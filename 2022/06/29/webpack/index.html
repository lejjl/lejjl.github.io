<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>webpack | sanren</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"example.com","root":"/","title":"云游君的小站","version":"1.10.4","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="1.webpack的构建流程是什么初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数,形成最后的配置结果； 开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件 监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的run方法开始执行编译； 确定入口：从配置的entry入口，开始解析文件构建AST语法">
<meta property="og:type" content="article">
<meta property="og:title" content="webpack">
<meta property="og:url" content="http://example.com/2022/06/29/webpack/index.html">
<meta property="og:site_name" content="sanren">
<meta property="og:description" content="1.webpack的构建流程是什么初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数,形成最后的配置结果； 开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件 监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的run方法开始执行编译； 确定入口：从配置的entry入口，开始解析文件构建AST语法">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-29T09:11:53.713Z">
<meta property="article:modified_time" content="2022-06-29T09:16:39.806Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="John Doe"><img width="96" loading="lazy" src="/yun.png" alt="John Doe"></a><div class="site-author-name"><a href="/about/">John Doe</a></div><span class="site-name">sanren</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">12</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">1.webpack的构建流程是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-webpack-%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">2.webpack 的热更新原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-webpack-%E6%89%93%E5%8C%85%E6%98%AFhash%E7%A0%81%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text">3.webpack 打包是hash码是如何生成的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-webpack-%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">4.webpack 离线缓存静态资源如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-webpack-%E5%B8%B8%E8%A7%81%E7%9A%84plugin%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.</span> <span class="toc-text">5.webpack 常见的plugin有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-webpack-%E6%8F%92%E4%BB%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">6.webpack 插件如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-webpack%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E2%BB%85%E7%9A%84Loader"><span class="toc-number">7.</span> <span class="toc-text">7.webpack有哪些常⻅的Loader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-webpack%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96%E7%BC%93%E5%AD%98"><span class="toc-number">8.</span> <span class="toc-text">8.webpack如何实现持久化缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E2%BD%A4webpack%E6%9D%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">9.如何⽤webpack来优化前端性能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-webpack-treeShaking%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">10.webpack treeShaking机制的原理</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://example.com/2022/06/29/webpack/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="sanren"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">webpack</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2022-06-29 17:11:53" itemprop="dateCreated datePublished" datetime="2022-06-29T17:11:53+08:00">2022-06-29</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h4 id="1-webpack的构建流程是什么"><a href="#1-webpack的构建流程是什么" class="headerlink" title="1.webpack的构建流程是什么"></a>1.webpack的构建流程是什么</h4><p><code>初始化参数</code>：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数,形成最后的配置结果；</p>
<p><code>开始编译</code>：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件 监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的run方法开始执行编译；</p>
<p><code>确定入口</code>：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去；</p>
<p><code>编译模块</code>：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</p>
<p><code>完成模块编译并输出</code>：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry或分包配置生成代码块chunk;</p>
<p><code>输出完成</code>：输出所有的chunk到文件系统；</p>
<h4 id="2-webpack-的热更新原理"><a href="#2-webpack-的热更新原理" class="headerlink" title="2.webpack 的热更新原理"></a>2.webpack 的热更新原理</h4><p>其实是自己<code>开启了express应用</code>，添加了对webpack编译的监听，添加了和浏览器的websocket长连接，当文件变化触发webpack进行编译并完成后，<code>会通过sokcet消息告诉浏览器准备刷新</code>。而为了减少刷新的代价，就是<code>不用刷新网页</code>，而是<code>刷新某个模块</code>，webpack-dev-server可以支持热更新，通过生成 文件的hash值来比对需要更新的模块，浏览器再进行热替换</p>
<p><strong>服务端</strong></p>
<ul>
<li><p>启动 webpack-dev-server服务器</p>
</li>
<li><p>创建webpack实例</p>
</li>
<li><p>创建server服务器</p>
</li>
<li><p>添加webpack的done事件回调</p>
</li>
<li><p>编译完成向客户端发送消息</p>
</li>
<li><p>创建express应用app</p>
</li>
<li><p>设置文件系统为内存文件系统</p>
</li>
<li><p>添加 webpack-dev-middleware 中间件</p>
</li>
<li><p>中间件负责返回生成的文件</p>
</li>
<li><p>启动webpack编译</p>
</li>
<li><p>创建http服务器并启动服务</p>
</li>
<li><p>使用sockjs在浏览器端和服务端之间建立一个websocket长连接</p>
</li>
<li><p>创建socket服务器</p>
</li>
</ul>
<p><strong>客户端</strong></p>
<ul>
<li>webpack-dev-server/client端会监听到此hash消息</li>
<li>客户端收到ok消息后会执行reloadApp方法进行更新</li>
<li>在reloadApp中会进行判断，是否支持热更新，如果支持的话发生 webpackHotUpdate事件，如果不支持就直接刷新浏览器</li>
<li>在 webpack/hot/dev-server.js 会监听 webpackHotUpdate 事件</li>
<li>在check方法里会调用module.hot.check方法</li>
<li>HotModuleReplacement.runtime请求Manifest</li>
<li>通过调用 JsonpMainTemplate.runtime 的 hotDownloadManifest方法</li>
<li>调用JsonpMainTemplate.runtime的hotDownloadUpdateChunk方法通过JSONP请求获取最新的模块代码</li>
<li>补丁js取回来或会调用 JsonpMainTemplate.runtime.js 的 webpackHotUpdate 方法</li>
<li>然后会调用 HotModuleReplacement.runtime.js 的 hotAddUpdateChunk方法动态更新 模块代码</li>
<li>然后调用hotApply方法进行热更</li>
</ul>
<h4 id="3-webpack-打包是hash码是如何生成的"><a href="#3-webpack-打包是hash码是如何生成的" class="headerlink" title="3.webpack 打包是hash码是如何生成的"></a>3.webpack 打包是hash码是如何生成的</h4><p>   1.webpack生态中存在多种计算hash的方式</p>
<ul>
<li><code>hash</code></li>
<li><code>chunkhash</code></li>
<li><code>contenthash </code></li>
</ul>
<p>hash代表每次webpack编译中生成的hash值，所有使用这种方式的文件hash都相同。每次构建都会使webpack计算新的hash。chunkhash基于入口文件及其关联的chunk形成，某个文件的改动只会影响与它有关联的chunk的hash值，不会影响其他文件contenthash根据文件内容创建。当文件内容发生变化时，contenthash发生变化</p>
<p>2.避免相同随机值</p>
<ul>
<li>webpack在<code>计算hash后分割chunk</code>。<code>产生相同随机值可能是因为这些文件属于同一个chunk,可以将某个文件提到独立的chunk（如放入entry）</code></li>
</ul>
<h4 id="4-webpack-离线缓存静态资源如何实现"><a href="#4-webpack-离线缓存静态资源如何实现" class="headerlink" title="4.webpack 离线缓存静态资源如何实现"></a>4.webpack 离线缓存静态资源如何实现</h4><ul>
<li>在配置webpack时，我们可以使用html-webpack-plugin来注入到和html一段脚本来实现将第三方或者共用资源进行 静态化存储在html中注入一段标识，例如 <code>&lt;% HtmlWebpackPlugin.options.loading.html %&gt;</code> ,在 html-webpack-plugin 中即可通过配置html属性，将script注入进去</li>
<li>利用 webpack-manifest-plugin 并通过配置 webpack-manifest-plugin ,生成 manifestjson 文件，用来对比js资源的差异，做到是否替换，当然，也要写缓存script</li>
<li>在我们做Cl以及CD的时候，也可以通过编辑文件流来实现静态化脚本的注入，来降低服务器的压力，提高性能</li>
<li>可以通过自定义plugin或者html-webpack-plugin等周期函数，动态注入前端静态化存储script</li>
</ul>
<h4 id="5-webpack-常见的plugin有哪些"><a href="#5-webpack-常见的plugin有哪些" class="headerlink" title="5.webpack 常见的plugin有哪些"></a>5.webpack 常见的plugin有哪些</h4><ul>
<li><code>ProvidePlugin</code>：自动加载模块，代替require和import</li>
<li><code>html-webpack-plugin</code>可以根据模板自动生成html代码，并自动引用css和js文件</li>
<li><code>extract-text-webpack-plugin</code> 将js文件中引用的样式单独抽离成css文件</li>
<li><code>DefinePlugin</code> 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。</li>
<li><code>HotModuleReplacementPlugin</code> 热更新</li>
<li><code>optimize-css-assets-webpack-plugin</code> 不同组件中重复的css可以快速去重</li>
<li><code>webpack-bundle-analyzer</code> 一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示。</li>
<li><code>compression-webpack-plugin</code> 生产环境可采用gzip压缩JS和CSS</li>
<li><code>happypack</code>：通过多进程模型，来加速代码构建</li>
<li><code>clean-wenpack-plugin</code> 清理每次打包下没有使用的文件</li>
<li><code>speed-measure-webpack-plugin</code>:可以看至U每个Loader和Plugin执行耗时（整个扌丁包耗时、每个Plugin和 Loader 耗时）</li>
<li><code>webpack-bundle-analyzer</code>:可视化Webpack输出文件的体积（业务组件、依赖第三方模块</li>
</ul>
<h4 id="6-webpack-插件如何实现"><a href="#6-webpack-插件如何实现" class="headerlink" title="6.webpack 插件如何实现"></a>6.webpack 插件如何实现</h4><ul>
<li><p>webpack本质是一个事件流机制，核心模块：tabable(Sync + Async)Hooks 构造出 === Compiler(编译) + Compiletion(创建bundles)</p>
</li>
<li><p>compiler对象代表了完整的webpack环境配置。这个对象在启动webpack时被一次性建立，并配置好所有可操作的设置，包括options、loader和plugin。当在webpack环境中应用一插件时，插件将收到此compiler对象的引用。可以使用它来访问webpack的主环境</p>
</li>
<li><p>compilation对象代表了一次资源版本构建。当运行webpack开发环境中间件时，每当检测到一个文件变化，就会创建一个新的compilation,从而生成一个新的编译资源。一个compilation对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态的信息。compilation对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用</p>
</li>
<li><p>创建一个插件函数，在其prototype上定义apply方法，指定一个webpack自身的事件钩子</p>
</li>
<li><p>函数内部处理webpack内部实例的特定数据</p>
</li>
<li><p>处理完成后，调用webpack提供的回调函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyWebpackPlugin</span>(<span class="params"></span>)(<span class="params"></span></span><br><span class="line"><span class="params">&#125;；</span></span><br><span class="line"><span class="params"><span class="comment">// prototype 上定义 apply 方法</span></span></span><br><span class="line"><span class="params">MyWebpackPlugin.prototype.apply=<span class="keyword">function</span>()&#123;</span></span><br><span class="line"><span class="params">// 指定一个事件函数挂载到webpack</span></span><br><span class="line"><span class="params">compiler.pluginCwebpacksEventHook<span class="string">&quot;funcion (compiler)( console. log(“这是一个插件”)；</span></span></span><br><span class="line"><span class="string"><span class="params">// 功能完成调用后webpack提供的回调函数</span></span></span><br><span class="line"><span class="string"><span class="params">callback()</span></span></span><br><span class="line"><span class="string"><span class="params">&#125;)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-webpack有哪些常⻅的Loader"><a href="#7-webpack有哪些常⻅的Loader" class="headerlink" title="7.webpack有哪些常⻅的Loader"></a>7.webpack有哪些常⻅的Loader</h4><ul>
<li><code>file-loader</code>：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件</li>
<li><code>url-loader</code>：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去</li>
<li><code>source-map-loader</code>：加载额外的 Source Map ⽂件，以⽅便断点调试</li>
<li><code>image-loader</code>：加载并且压缩图⽚⽂件</li>
<li><code>babel-loader</code>：把 ES6 转换成 ES5</li>
<li><code>css-loader</code>：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性</li>
<li><code>style-loader</code>：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。</li>
<li><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码</li>
</ul>
<h4 id="8-webpack如何实现持久化缓存"><a href="#8-webpack如何实现持久化缓存" class="headerlink" title="8.webpack如何实现持久化缓存"></a>8.webpack如何实现持久化缓存</h4><ul>
<li><code>服务端设置http缓存头</code>（cache-control）</li>
<li>打包依赖和运行时到不同的chunk，<code>即作为splitChunk,因为他们几乎是不变的</code></li>
<li><code>延迟加载</code>：使用<code>import()方式</code>，可以动态加载的文件分到独立的chunk,以得到自己的chunkhash</li>
<li><code>保持hash值的稳定</code>：编译过程和文件内通的更改尽量不影响其他文件hash的计算，对于低版本webpack生成的增量数字id不稳定问题，可用hashedModuleIdsPlugin基于文件路径生成解决</li>
</ul>
<h4 id="9-如何⽤webpack来优化前端性能？"><a href="#9-如何⽤webpack来优化前端性能？" class="headerlink" title="9.如何⽤webpack来优化前端性能？"></a>9.如何⽤<strong>webpack</strong>来优化前端性能？</h4><p>⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p>
<ul>
<li><code>压缩代码</code>：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css</li>
<li><code>利⽤CDN加速</code>: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径</li>
<li><code>Tree Shaking</code>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 –optimize-minimize 来实现</li>
<li><code>Code Splitting</code>: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存</li>
<li><code>提取公共第三⽅库</code>: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</li>
</ul>
<h4 id="10-webpack-treeShaking机制的原理"><a href="#10-webpack-treeShaking机制的原理" class="headerlink" title="10.webpack treeShaking机制的原理"></a>10.webpack treeShaking机制的原理</h4><ul>
<li>treeShaking 也叫<code>摇树优化</code>，是一种通过移除多于代码，来优化打包体积的，<code>生产环境默认开启</code>。</li>
<li>可以在<code>代码不运行</code>的状态下，分析出<code>不需要的代码</code>；</li>
<li>利用es6模块的规范<ul>
<li>ES6 Module引入进行<code>静态分析</code>，故而<code>编译的时候正确判断到底加载了那些模块</code></li>
<li>静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码</li>
</ul>
</li>
</ul>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>John Doe</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2022/06/29/webpack/" title="webpack">http://example.com/2022/06/29/webpack/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/06/29/%E7%AC%94%E8%AE%B0/" rel="prev" title="笔记"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">笔记</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/06/29/vue3%E4%BB%A5%E5%8F%8Avue2%E5%BC%BA%E5%8C%96/" rel="next" title="VUE3"><span class="post-nav-text">VUE3</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> John Doe</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.2</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.4</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>